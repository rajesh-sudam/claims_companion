"""Claims management routes.

This module defines endpoints for creating, reading and updating
insurance claims. Each endpoint requires a valid bearer token so
that claims are scoped to the authenticated user. A simple claim
number generator provides unique identifiers.
"""

from __future__ import annotations

import random
import string
from datetime import datetime, date
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Header
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy import text

from ..db import get_db
from ..models import Claim, ClaimProgress, User
from ..auth_utils import decode_access_token

router = APIRouter()


def _get_user_id(authorization: str | None) -> int:
    """Extract the user ID from the bearer token.

    Raises HTTPException with 401 status if the header is missing or
    invalid.
    """
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing token")
    token = authorization.split(" ", 1)[1]
    payload = decode_access_token(token)
    try:
        return int(payload.get("sub"))
    except Exception:
        raise HTTPException(status_code=401, detail="Invalid token payload")


class CreateClaimRequest(BaseModel):
    claim_type: str
    incident_date: Optional[date] = None
    incident_description: Optional[str] = None


@router.post("")
def create_claim(body: CreateClaimRequest, db: Session = Depends(get_db), authorization: str | None = Header(default=None)):
    """Create a new claim for the authenticated user.

    A unique claim number is generated by combining the user ID with
    a random sequence. A default progress step is inserted to
    indicate that the claim was submitted.
    """
    user_id = _get_user_id(authorization)

    # Generate a claim number: CLM{userId:04d}{rand:06d}
    rand_part = ''.join(random.choices(string.digits, k=6))
    claim_number = f"CLM{user_id:04d}{rand_part}"

    claim = Claim(
        claim_number=claim_number,
        user_id=user_id,
        claim_type=body.claim_type,
        status="submitted",
        incident_date=body.incident_date,
        incident_description=body.incident_description,
    )
    db.add(claim)
    db.commit()
    db.refresh(claim)

    # Insert default progress step
    step = ClaimProgress(
        claim_id=claim.id,
        step_id="submitted",
        step_title="Claim Submitted",
        status="completed",
        completed_at=datetime.utcnow(),
        description=f"Your claim has been received and assigned number {claim.claim_number}"
    )
    db.add(step)
    db.commit()

    return {"claim": {"id": claim.id, "claim_number": claim.claim_number, "status": claim.status, "claim_type": claim.claim_type}}


@router.get("")
def list_claims(db: Session = Depends(get_db), authorization: str | None = Header(default=None)):
    """Return all claims belonging to the authenticated user."""
    user_id = _get_user_id(authorization)
    claims = db.query(Claim).filter(Claim.user_id == user_id).order_by(Claim.created_at.desc()).all()
    return {"claims": [
        {
            "id": c.id,
            "claim_number": c.claim_number,
            "claim_type": c.claim_type,
            "status": c.status,
            "incident_date": c.incident_date.isoformat() if c.incident_date else None,
            "estimated_completion": c.estimated_completion.isoformat() if c.estimated_completion else None,
        }
        for c in claims
    ]}


@router.get("/{claim_id}")
def get_claim(claim_id: int, db: Session = Depends(get_db), authorization: str | None = Header(default=None)):
    """Return details of a single claim if owned by the authenticated user."""
    user_id = _get_user_id(authorization)
    claim = db.query(Claim).filter(Claim.id == claim_id, Claim.user_id == user_id).first()
    if not claim:
        raise HTTPException(status_code=404, detail="Claim not found")
    return {"claim": {
        "id": claim.id,
        "claim_number": claim.claim_number,
        "claim_type": claim.claim_type,
        "status": claim.status,
        "incident_date": claim.incident_date.isoformat() if claim.incident_date else None,
        "incident_description": claim.incident_description,
        "estimated_completion": claim.estimated_completion.isoformat() if claim.estimated_completion else None,
    }}


class UpdateClaimRequest(BaseModel):
    status: Optional[str] = None
    incident_description: Optional[str] = None


@router.put("/{claim_id}")
def update_claim(claim_id: int, body: UpdateClaimRequest, db: Session = Depends(get_db), authorization: str | None = Header(default=None)):
    """Update an existing claim. Only status and description can be updated."""
    user_id = _get_user_id(authorization)
    claim = db.query(Claim).filter(Claim.id == claim_id, Claim.user_id == user_id).first()
    if not claim:
        raise HTTPException(status_code=404, detail="Claim not found")
    if body.status:
        claim.status = body.status
    if body.incident_description:
        claim.incident_description = body.incident_description
    db.commit()
    return {"claim": {"id": claim.id, "status": claim.status}}


@router.get("/{claim_id}/progress")
def get_claim_progress(claim_id: int, db: Session = Depends(get_db), authorization: str | None = Header(default=None)):
    """Return the progress timeline for a claim."""
    user_id = _get_user_id(authorization)
    claim = db.query(Claim).filter(Claim.id == claim_id, Claim.user_id == user_id).first()
    if not claim:
        raise HTTPException(status_code=404, detail="Claim not found")
    steps = db.query(ClaimProgress).filter(ClaimProgress.claim_id == claim_id).order_by(ClaimProgress.created_at).all()
    # Transform the ClaimProgress records into the shape expected by the frontend.
    # If there are no steps yet, return an empty list. The Node.js API
    # returned just an array under the key `progress`.
    if not steps:
        return {"progress": []}
    progress_list = []
    for step in steps:
        progress_list.append({
            "id": step.id,
            "step_id": step.step_id,
            "step_title": step.step_title,
            "status": step.status,
            "completed_at": step.completed_at.isoformat() if step.completed_at else None,
            "description": step.description,
        })
    return {"progress": progress_list}


@router.post("/{claim_id}/documents")
def upload_documents(claim_id: int, authorization: str | None = Header(default=None)):
    """Placeholder endpoint for document upload.

    In this MVP the actual upload and storage mechanism is not
    implemented. We return a 200 response to satisfy frontend calls.
    """
    _ = _get_user_id(authorization)
    return {"ok": True}